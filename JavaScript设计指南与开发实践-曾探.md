# 1.面向对象的JavaScript编程
### 1.1 动态类型语言和鸭子类型
* JavaScript是一门动态类型语言。
* 利用"鸭子类型"的思想，我们可以在动态类型语言中实现"面向接口编程"。  
### 1.2多态
* 多态的含义：同一操作作用于不同的对象上面，可以有不同的解释和执行效果。
* 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。
### 1.3 封装
* 封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节，设计细节以及隐藏对象的类型等。
### 1.4原型模式和基于原型继承的javascript对象系统
>**原型模式**  

* 原型模式通过克隆来创建对象。原型模式的实现关键，是语言本身是否提供了clone方法。

* 原型模式的真正目的并非在于要得到一个一模一样的对象，而是提供了一种更为便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。

* javascript本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式 来搭建的，在这里称之为原型编程范型也许更合适。

* 在基于原型的语言中，没有类的概念，每一个对象都是由其他对象克隆来的。也就是说，这类语言的类是依靠原型链来模拟的。

* 原型编程中的一个重要特性，当某个对象无法响应某个请求是，会把该请求委托给自己的原型。

#### javascript中的对象系统
* javascript的根对象是`object.prototype`,它是一个空的对象。
* javascript中的函数不仅可以作为函数来调用，也可以作为构造器来调用，事实上，当我们使用`new`运算符来创建对象时，就是将函数作为构造器使用。
* `__proto__`是对一个对象原型链的引用。默认会指向它的构造器的原型对象。在某一些浏览器中，`__proto__`是被公开的。
* 原型继承的核心代码便是指定prototype
```
var A=function(){};
A.prototype={name:'sven'};

var B=function(){};
B.prototype=new A();  //B的原型引用指向 A

var b=new B();      
console.log(b.name);  //sven
```
# 2. this,call和apply
### 2.1 this
1. this的指向
    * 作为对象的方法调用：指向该对象。
    * 作为普通函数调用：指向全局对象window。
    * 在构造器中使用：指向新建的这个对象。
### 2.2 call和apply
`apply`第一个参数为`this`的指向(也就是作用域)，第二个参数为函数参数数组.    

`call`第一个参数为`this`的指向,第二个参数往后依次传入函数参数.
##### call和apply的用途
1. 改变this指向.
2. 模拟`function.prototype.bind`函数.
3. 借用其他对象的方法(类似继承).

# 3. 闭包和高阶函数
### 3.1 闭包
#### 闭包的作用
1. 封装变量
2. 延续局部变量的寿命
    ```
    var report=(function(){
        var imgs=[];
        return function(src){
            var img=new Image();    
            imgs.push(img);
            img.src=src;
        }
    })();
    ```
    将需要保护的变量放在return的函数中，可以延续局部变量的寿命，使其不被当成垃圾清除掉。
#### 用闭包实现命令模式
命令模式的意图是把请求封装为对象,从而请求的发起者和请求的接收者之间的耦合关系。
#### 闭包与内存管理
如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为null即可。
### 3.2 高阶函数
高阶函数是
1. 函数可以当作参数被传递。
2. 函数可以作为函数值输出。
#### 把函数作为参数传递
1. 回调函数
```
