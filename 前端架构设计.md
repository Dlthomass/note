# 前端架构设计

## 第一章 前端架构原则

> 前端架构是一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效可持续的工具流。

前端架构师的工作职责：
1. 体系设计
2. 工作规划
3. 监督跟进

## 第二章  Alpha项目

#### 2.1 慢而有力的开端

对网站构建的一些愿望：
1. 模块化内容
2. 全面测试
3. 流式处理
4. 详细的文档

## 第三章 前端架构的核心

#### 3.1 围绕四个核心工作
#### 3.2 四个核心的含义
1. **代码** 专注于如何实现系统架构中的HTML，CSS和JavaScript。
2. **流程**
3. **测试** 根据团队的规模，测试方案有时会细分为很多部分，如前端、后端和运维。
4. **文档** 将会介绍团队需要编写的各种文档类型、发布文档的工具，以及阅读这些文档的用户角色。

## 第四章 HTML

#### 4.1 过去处理标记的方法
1. 程序式标记：自动化程度100%，可控程度0%。
2. 静态标记：自动化程度0%，可控程度100%。

#### 4.2 解决方案：平衡可控性和自动化
##### 模块化标记：自动化程度100%，可控程度100%

#### 4.4 模块化css理论的多面性
##### 4.4.1 面向对象CSS
```html
<div class="toggle simple">
<div class="toggle-control open">
<h1 class="toggle-title">Title 1</h1>
</div>
<div class="toggle-details open"> ... </div>
...
</div>
```
OOCSS的两个主要原则：
1. **分离结构和外观。** 将视觉特性定义为可复用的单元。
2. **分离容器和内容。** 不再将元素作为样式的限定词。

bootstrap就是一个优秀的例子。

##### 4.4.2 SMACSS方法
```html
<div class="toggle toggle-simple">
 <div class="toggle-control is-active">
 <h2 class="toggle-title">Title 1</h2>
 </div>
 <div class="toggle-details is-active">
 ...
 </div>
 ...
 </dl>
 ```
 SMACSS 的不同点是把样式系统划分为五个具体类别：
 1. 基础
 2. 布局
 3. 模块
 4. 状态
 5. 主题


 ##### 4.4.3 BEM方法
 BEM是CSS类名的命名规则，它建议每个元素都带有如下内容的CSS类名：
 * 块名
 * 元素
 * 修饰符
 如：toggle__details--active。
 ```html
 <div class="toggle toggle--simple">
<div class="toggle__control toggle__control--active">
<h2 class="toggle__title">Title 1</h2>
</div>
<div class="toggle__details toggle__details--active">
...
</div>
...
</dl>
```

当然，最重要的还是选择一个合适的解决方案。

## 第五章 CSS
#### 5.1 特性之争与继承之痛
#### 5.2 一种现代的、模块化的方法
#### 5.3 其他有助益的原则
##### 5.3.1 单一职责原则
单一责任原则规定你创建的所有东西必须有单一的、高度聚焦的理由。你应用到某个选择器里的样式应该是为了单一目的而创建的，并且能够很好地实现这个目标。
##### 5.3.2 单一样式来源
单一样式来源的方法将单一责任理论应用到更深层次，不仅每个 CSS 类名被创建为单一用途，而且每个标签的样式也只有单一的来源。

在一个模块化设计中，任何组件的设计必须由组件本身决定，而不应该被它的父类名限制。
##### 5.5.3 组件修饰符
组件修饰符（又称皮肤或者子组件，取决于你所赞同的方法论）让你能够定义一个组件在多个不同情况下的多种变化。它的工作方式和单一样式的来源方法非常相似，但是修饰符类名的属性不再是父组件，而是组件本身的一部分

## 第六章 JavaScript
#### 6.1 选择框架
根据需要决定是否应该选择框架，而不是一上来就大套工具和起始页，除非增加复杂度和代码体积利大于弊，否则不要轻易放弃精简方案。

#### 6.2 维护整洁的JavaScript代码
##### 6.2.1 保持代码整洁
可以使用JSHint等代码检查工具来检查你的代码。
##### 6.2.2 创造可复用的函数

## 第七章 RED HAT代码
#### 7.1 过多的依赖
#### 7.2 严重的位置依赖问题
#### 7.3 设计分解
#### 7.4 组件分类
#### 7.6 编写你自己的规则
编写规则时需要遵循的规范：
* 只包含不可变的规则，而不是笼统的说明
* 总是把规则提炼成最简单的表达
* 总是首先说明规则是什么，再说明“如果不这样，那么会如何”
* 每个规则必须包含以下词中的一个——总是、永远不要、只有、每一个、不要、要
#### 7.7 每个标签指定唯一的选择器
##### 7.7.1 单一责任原则
在某些领域，CSS 的单一责任原则意味着每个 CSS 类都有一个简单的、高度聚焦的责任，所以在某个场景下，用一个 CSS 类来设置元素的盒模型的属性，另一个设置排版，还有一个设置颜色和背景。
##### 7.7.2 样式只有单一的来源
##### 7.7.3 可选的修饰符
##### 7.7.4 可选的上下文
#### 7.8 语义化的网络

## 第八章 工作流
工作流指的是把想法变成现实的过程，或者从产品的角度来看，就是解决 bug、需求迭代的一系列流程和方法。
#### 8.1 过去的开发工作流
#### 8.2 现在的开发工作流
##### 8.8.1 需求
工作流一般是从收集需求开始的，因为只有这样我们才能够定义出项目内容和衡量项目成败的标准。
##### 8.8.2 原型设计
原型设计提供了一个讨论和反馈的公共空间，它把丰满的想法实现在桌面和手机浏览器中。
##### 8.8.3 程序开发
### 8.3 前端工作流
##### 8.3.1 必要的工具
##### 8.3.2 本地部署
跟版本控制器打交道，往往是工程师上班时要做的第一件事，也是他下班前做的最后一件事。
##### 8.3.3 编写用户故事
不管你叫它们任务、标签、故事还是作业，我们都需要通过沟通把人的想法和愿望提炼成一个精准的、可操作的和可检验的要求。因为没有人会读心术，所以我们需要编写用户故事，详细地描述问题的缘由、建议的解决方案和必须满足的需求点。

通过关注组件而非单页面的内容，我们可以保证优先考虑的是设计系统，以及改动对系统产生的影响。这样的方式创建了一个更具弹性的系统，有助于避免多个页面之间的冲突。

### 8.4 开发
### 8.5 发布
### 8.6 提交编译后的资源
在版本控制器中，最好的方法是只提交少量必要的代码。
### 8.7 持续集成的服务器
##### 8.7.1 标签分支
不管是发布到线上服务器，还是发布渠道（我们后面会介绍），标签是发布代码的一种便捷方式。标签的一个好处是，它可以基于任何分支，而不仅仅是线上分支。
##### 8.7.2 究竟为什么要这么做
发布软件的一个方法是为软件的每个版本创建一个发布分支。

有效利用标签分支的另一个方法是只在那些标签分支上提交你编译后的资源。
### 8.8 发布渠道
软件包管理器的好处如下。
* 发布不同的版本
* 用户很容易知道什么时候有新版本可用
* 只发布那些用户所需的文件
* 从私有代码库中发布代码

## 第九章 任务处理器
### 9.1 在任务处理器中完成一切
任务处理器使前端架构师能够创建网站的蓝图。四个核心都被打包成自动化流程，通过自动化技术，我们不仅规范了流程，同时还对它进行了优化。代码检查工具能够帮助我们规范和提高代码标准。测试组件在本地或者持续集成工具（比如 Jenkins 或 TravisCI）中运任务处理器 中运行。只需点一下鼠标，就可以持续编译出新的代码并发布到线上。此外，文档还可以自动读取代码中的注释、模板文件和描述大纲。
### 9.2 在项目中使用任务处理器

## 第十章 RAD HAT流程
### 10.1 征服最后一英里
##### 一系列标准的产出
* JSON模式
* 模板文件
* Sass partial
* 可视化的回归测试
* 测试数据
* 文档
* 文档数据

### 10.2 模式驱动的设计系统
目前为止，在软件开发领域，测试驱动的设计是一种很常见且被广泛接受的开发方式。在动手编写具体的代码之前，我们先写好一套测试用例，用来描述该代码应该完成什么样的功能。

在模式驱动的设计系统中，我们首先关注的是设计的内容和用户接口，而不是那些标记和 CSS。

通过遵循公共的标准，我们一直在寻找可以给设计系统带来价值和功能的第三方工具。对
模式系统的坚持所带来的回报是多方面的，以至于我确信自己以后再也不会创造不带模式
的设计系统了。这就是模式驱动的设计系统的魅力。

## 第11章 单元测试
### 11.1 单元
“一次只做一件事，并把它做好”是构建基于单元测试的应用程序的原则。
### 11.2 测试驱动的开发
大多数人在首次接触单元测试时，可能写过一些功能代码以满足业务需求（比如上文中的
计算运费的例子），然后也努力地将它重构为更小的、可重用的、可测试的代码，之后才
去思考如何写测试用例。测试驱动的开发（test-driven development，TDD）则颠倒了一
思路，它将单元测试放在第一位，之后才是编写功能代码。
### 11.3 一个测试驱动的例子
单元测试的核心理念其实非常简单。它的基本思路是调用要测试的函数，传递一些预先设置好的参数，并描述结果应该是什么。
```js
//对calculateShipping的测试
QUnit.test('Calculate Shipping',function(assert) {
  assert.equal(calculateShipping(24),4,"24 Miles");
  assert.equal(calculateShipping(99),5,"99 Miles");
  assert.equal(calculateShipping(999),6,"999 Miles");
  assert.equal(calculateShipping(1000),7,"1000 Miles");
};
```

### 11.4 测试覆盖率要多大才足够
##### 解决分歧点
在决定从哪里开始写单元测试时，可以从能够获得最大收益的地方开始。
##### 从测试覆盖率开始
正如前面所说的，并不是所有的功能都需要同样的测试覆盖率。但前提是，每一个用户故
事都是以测试覆盖率的相关任务作为**开始**的。只有当所有人都认为给这些任务写测试用例没有必要时，才考虑去掉它。这样我们才能确信，对于任何需要测试的功能，都已经安排了足够的时间去完成它们。

## 第12章 性能测试
性能测试衡量的是影响用户使用网站的流畅程度的关键指标，包括页面大小、请求数量、
首字节时间（time to first byte，TTFB）、加载时间和滚动性能。

### 12.1 制定性能预算
制定性能预算是指为每个关键指标设定目标值，然后在所有代码合并或部署之前持续测试这些指标。若有任何一个指标没通过测试，则需要调整新增的功能，或删除一些其他功能。
##### 竞争基线
制定性能预算的一种方法是参考竞争对手。
##### 平均基准
不管你的竞争对手是谁，把你的网站性能基线与行业平均水准和通用的最佳实例相比较总是必不可少的。我们没有理由因为竞争对手的落后而保持平庸。
有几个值得注意的指标：
1. 页面大小
2. 总请求次数
3. 可缓存资源所占比例

### 12.2 原始指标
##### 页面大小
当你希望缩减页面的大小时，可以从以下几个显而易见的地方开始。
* **图片占据页面平均大小的 61%**
    * 优化 PNG 图片，并降低 JPEG 图片的质量。
    * 利用新的响应式的 <picture> 标记和 srcset 属性来下载大小合适的图片。
    * 制定一个预算，如果没有移除任何图片，就不增加图片大小。
* **太多自定义字体很快会使网页变得臃肿。**
    * 制定一个字体预算，不考虑增加第二种或第三种字体。
    * 考虑必要的字体粗细，因为每增加一种粗细变化，都会使字体文件增加几千个字节
    * 虽然图标字体很不错，但要注意文件大小，因为图标字体会使字体文件迅速变大。
* **JavaScript 框架、jQuery 插件和 CSS 框架常常使页面大小增加很多，却收效甚微。**
    * 很多网站都已远离 jQuery，因为 vanilla JS 就可以满足其需求，尤其是网站只针对现代浏览器时。
    * jQuery 插件虽然可能会提供一些很厉害的功能，却常常使页面大小显著增加。考虑在现代浏览器上使用 CSS 能否达到同样的效果，并在低版本浏览器上合理地回退。
    * 像 Angular 或者 Ember 这样的大型 JavaScript 框架也许能完成你的工作，但生成的网页大小会超出实际工作的需要。如果只需要使用 Angular 的视图层，那么最好使用React 或 Mustache 来替换。
    * CSS 框架往往是乱七八糟的。它包含可能会用到的所有想象得到的样式。虽然这对于网页快速成型很有帮助，但从现有的几千字节的 CSS 和 JavaScript 出发来构建网站，会让你在开始写第一行代码之前就陷入困境。
* **使用压缩**
    * JavaScript 可以在构建流程中以编程的方式进行压缩，而且可以在服务器将文件发送到浏览器之前使用 gzip 压缩。这些都是缩减网页大小的关键步骤。

##### HTTP请求次数
可以通过如下的方法减少并发请求次数。
* **减少 HTTP 请求的次数**
    * 不要提供数十个单独的 CSS 文件和 JavaScript 文件，而是把它们合并到一个文件中。
    * 把多个单独的图像文件合并成一个图像映射或者图标字体。
    * 延迟加载页面最初加载所不需要的资源。
* **增加浏览器每次并发请求的资源个数**
    * 分拆你的资源到不同的服务器（或者 CDN），可以使得浏览器单次并发下载更多的资源，因为浏览器的并发请求数量限制是针对单个服务器的。

### 12.3 计时度量
###### 首字节时间
首字节时间是指从浏览器请求网站页面开始，到浏览器接收到第一个字节之间的毫秒数。
###### 开始渲染时间
更有价值的计时度量是“开始渲染时间”。这个度量是指用户开始在页面上看到内容的时间。这意味着所有阻塞渲染的文件都已经加载完成，浏览器已经开始渲染文档模型了。可以通过以下方式优化开始渲染时间：延迟加载阻塞渲染的 JavaScript 和 CSS 文件、将关键的 CSS 代码内联到页面头部、用数据 URI 代替图片资源，以及延迟加载所有在文档模型渲染完成后才下载的资源。
###### 文档完成时间
只要最初请求的资源已经加载成功，就可以认为文档“完成”了。文档完成时间不包括JavaScript 中拉取资源消耗的时间，因此延迟加载的资源不会影响这个指标。

### 12.4 混合度量标准
##### PageSpeed分数
[PageSpeed](https://developers.google.com/speed/pagespeed/insights/)是 Google 开发的网站工具和 Chrome 浏览器的扩展程序，用来分析站点的性能和网站的可用性，它给出一个用百分比表示的分数，并解释了提高分数的方法。
##### Speed Index指标
根据 Speed Index 项目主页上的描述，[Speed Index](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index)指的是页面可见部分展示完成的平均时间，该指标通过用毫秒表示，并取决于视图端口的大小。

### 12.5 设置性能测试
##### [Grunt PageSpeed插件](https://www.npmjs.com/package/grunt-pagespeed)
这个 Grunt 插件可以自动化地运行 Google 的PageSpeed 来测试我们的站点。

##### [Grunt Perfbuget插件](https://github.com/tkadlec/grunt-perfbudget)
WebPageTest 可以通过模拟不同的网络连接类型和全球的地理位置来测试网站的多个指标。

## 第13章 视觉还原测试
### 13.1 常见的质疑
##### 不了解情况的开发者
即使你的代码完美无缺，也会被其他开发者的短短几行不正确的代码破坏掉。
##### 不一致的设计
##### 举棋不定的决策者
在公开发布前对功能进行原型开发是没有问题的，事实上这是很好的实践。但原型需要基于设计快速迭代之后的最终设计稿做出，最终结果是一个大家一致认可的产品。

### 13.2 一个经过测试的解决方案
视觉还原测试让我们可以将正在开发的版本或者即将部署的版本（新版本）与正确的版本
（基线版本）进行视觉对比。这个过程只不过是抓取基线版本的截图，与最新版本进行对
比，并找出像素层面的差异。

### 13.3 视觉还原测试的多面性
##### 基于页面的比较
[Wraith](https://github.com/BBC-News/wraith)是一个基于页面的比较的例子。它使用YAML 作为设置文件，因此可以很轻松地比较来自两个不同来源的一大串页面列表。当你不期望两个不同来源的页面有任何差异时，比如需要比较线上页面和在工作中即将部署的页面时，这个方法会很合适。

##### 基于组件的比较
在基于组件或基于选择器的比较方面，[BackstopJS](https://github.com/garris/BackstopJS)是一个绝佳的选择。基于组件的比较工具使你可以抓取独立的页面片段进行对比，这样可以写出更有针对性的测试，并防止误报。

##### CSS单位测试
##### 基于无头浏览器的测试
##### 基于桌面浏览器的测试
##### 包含脚本库文件
##### 基于图形用户界面的比较工具，支持更改确认
##### 基于命令行的比较工具，支持更改确认

## 第14章 RAD HAT测试方法
### 14.1 实践视觉还原测试

## 第15章 文档核心
### 何为文档
##### 静态文档
[Hologram](https://github.com/trulia/hologram)是基于 Ruby 的通用文档工具，你可以在代码库中写小段的注释，然后通过它来收集这些注释生成的静态页面。

[SassDoc](http://sassdoc.com/)是基于 Node 的 系统文档 工 具，如果你正在构建一个大型的 Sass 框架，或者一个复杂的栅格或颜色系统，SassDoc 正是你想要的工具。

##### 代码驱动的文档
Pattern Lab 是多平台模式库工具，它使你可以模块化地开发设计系统，并将模板和 CSS 转换成可浏览的模式库。

JSON 模式是用于描述数据格式的语言，同时也可以说明数据的验证方式。在前端架构的领域中，可以用 JSON 模式来描述模板和模式所需要的数据。

## 第15章 样式文档
### Hologram
既然样式表已从一长串的声明演化为一个拥有变量、函数和逻辑的系统，那么也要保证文档系统的演化能跟上节奏。[Hologram](http://trulia.github.io/hologram/)提供了构建稳健的文档系统所需的一切内容。它允许我们在实际编写代码时，直接在 Sass 或者 JavaScript 文件中给系统进行注释。Hologram 会自动收集这些注释的内容，并转化为一个含有渲染示例和代码示例的可访问网站。

### SassDoc
[SassDoc](http://sassdoc.com/)则完全相反。它是一个记录 Sass 的变量、混入、继承和函数的工具，而且对每个注释块后面的代码都有严格的要求。另外，它对文档的呈现和风格也很讲究。

## 第16章 图形库
原子设计是一种构建网站设计系统的方法论。它不是一次性地设计整个页面，而是首先把网页常用元素分解成各个尺寸的模式，然后再描述把这些模式组合成一个完整网页的方式。这些模式中不可再分的最小单位就称为原子。原子是构造网站、标题、列表样式、图片、视频和表单元素的基本结构单元。

### 16.1 何为Pattern Lab
Pattern Lab（又称 PL）是一个静态网站生成器，它可以记录所有的网站结构单元。它把原子、分子、有机体和布局变成可浏览的网页，你不仅可以从中看到每个原子组件，还可以使用自定义的内容创造样例页面，模仿实际的网站效果。

### 16.2 运行Pattern Lab
理解系统背后的运行原理的最好方式，就是从一个完善的界面开始，逆向推出系统的模
板，还有 Pattern Lab 用到的数据文件。

所有的文件按不同层级，分别放在 5 个不同的文件夹中：原子、分子、有机
体、模板、页面。每个模式都有一个文件，描述组成按钮、轮播图片或底部导航栏的标记。在页面这一层级上，只需选择模板并添加内容就可以生成页面，上面的模式也会有关联文件，让我们可以把 lorem ipsum 字符（或“乱数假文”）替换成真正的内容。
